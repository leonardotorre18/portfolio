---

---

<div id="Front3D"></div>

<style>
	#Front3D {
		width: 100%;
		height: 100%;
		pointer-events: none;
	}
</style>

<script>
	import * as THREE from "three";

	const container = document.getElementById("Front3D") || document.body;
	let width = container.clientWidth || 0;
	let height = container.clientHeight || 0;

	// // Create a scene
	const scene: THREE.Scene = new THREE.Scene();
	scene.background = null;
	// Create a camera
	const camera = new THREE.PerspectiveCamera(40, width / height, 1, 5000,);
	camera.position.z = 120 - (width / 90);

	// create a renderer
	const renderer: THREE.WebGLRenderer = new THREE.WebGLRenderer();
	renderer.setSize(window.innerWidth, window.innerHeight);
	renderer.setAnimationLoop(() => {
		const time = performance.now() * 0.0005; // Get time in seconds
		const amplitude = 1; // Maximum distance the camera moves on the x-axis
		const speed = 0.8; // Speed of the oscillation
		camera.position.x = Math.sin(time * speed) * amplitude;
		camera.rotation.y = Math.sin(time * speed) * 0.01;
		// Apply a back-and-forth scaling effect
		const scaleAmplitude = 0.1; // Maximum scale variation
		const scaleSpeed = 0.35; // Speed of the scaling oscillation
		const scaleFactor = 1 + Math.sin(time * scaleSpeed) * scaleAmplitude;
		sphere.scale.set(50 * scaleFactor, 50 * scaleFactor, 50 * scaleFactor);

		camera.aspect = width / height;
		camera.updateProjectionMatrix();
		renderer.setSize(width, height);
		renderer.render(scene, camera);
	});
	renderer.setClearColor(0x000000, 0); // Set the renderer to transparent

	const sphere = new THREE.Mesh(
		new THREE.SphereGeometry(0.5, 32, 32), 
		new THREE.MeshStandardMaterial({ color: 0xf2f2f2 })
	);
	sphere.scale.set(50, 50, 50);
	sphere.position.set(60, -25, 10);
	scene.add(sphere);

	// create light
	const ambientLight = new THREE.AmbientLight(0xffffff, 1.7);
	const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
	directionalLight.position.set(10, 10, 10);
	scene.add(ambientLight);
	scene.add(directionalLight);

	container?.appendChild(renderer.domElement);

	window.addEventListener("resize", () => {
		width = container.clientWidth || 0;
		height = container.clientHeight || 0;

		camera.position.z = 120 - (width / 90);
		camera.aspect = width / height;
		camera.updateProjectionMatrix();
		renderer.setSize(width, height);
	});
</script>
